<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="/blog2-ssr/images/favicon-compressed.webp">
    <link rel="shortcut icon" href="/blog2-ssr/images/favicon-compressed.webp">
    <link rel="apple-touch-icon" href="/blog2-ssr/images/favicon-compressed.webp">

    <link rel="stylesheet" href="/blog2-ssr/shared.css">
    <link rel="stylesheet" href="/blog2-ssr/prism.css">

    <title>Big O notation</title></head>
<body class="svelte-1gr3n62"><style>:root{--left-side:200px;--right-side:200px;--nav-height:64px;--background-color:#FFD166;--primary-color:#06D6A0;--primary-accent-color:#049F76;--secondary-color:#118AB2;--sub-color:#073B4C;--nav-background:#fff;--article-background:#fff
    }body.svelte-1gr3n62.svelte-1gr3n62{padding:0;margin:0;color:var(--sub-color);background:var(--background-color);font-family:Roboto, "Helvetica Neue", Arial, sans-serif;font-size:18px;display:grid;grid-template:var(--nav-height) auto var(--nav-height)/var(--left-side) calc(100% - var(--left-side) - var(--right-side)) var(--right-side)
    }nav.top.svelte-1gr3n62 .links.svelte-1gr3n62{grid-area:1/2/2/3;display:flex;align-items:center
    }nav.top.svelte-1gr3n62 .links a.svelte-1gr3n62{margin-right:1em
    }a.svelte-1gr3n62.svelte-1gr3n62{color:var(--secondary-color);text-decoration:none
    }a.svelte-1gr3n62.svelte-1gr3n62:hover,a.svelte-1gr3n62.svelte-1gr3n62:active{color:var(--sub-color)
    }footer.svelte-1gr3n62.svelte-1gr3n62{grid-area:3/1/4/4;background:#fff;display:inline-grid;grid-template:100%/var(--left-side) auto var(--right-side)
    }nav.top.svelte-1gr3n62.svelte-1gr3n62{background-color:var(--nav-background);display:inline-grid;grid-template:100%/var(--left-side) auto var(--right-side);grid-area:1/1/2/4
    }main.svelte-1gr3n62.svelte-1gr3n62{grid-area:2/2/3/3;margin-top:1em;display:flex;flex-direction:column
    }@media screen and (max-width: 1340px){:root{--left-side:0px;--right-side:0px
        }body.svelte-1gr3n62.svelte-1gr3n62{background:var(--background-color)
        }nav.top.svelte-1gr3n62 .links.svelte-1gr3n62{justify-content:space-around
        }}
.btn.svelte-7idbpu{display:inline-flex;font-size:18px;color:#fff;background:var(--primary-color);padding:10px;border-radius:8px
    }.btn.svelte-7idbpu:hover{background:var(--primary-accent-color);color:#fff
    }</style>

    <nav class="top svelte-1gr3n62">
            <div class="links svelte-1gr3n62"><a class="nav-link nav-item svelte-1gr3n62" href="/blog2-ssr/">Home</a>
                <a class="nav-link nav-item svelte-1gr3n62" href="/blog2-ssr/about/">About</a></div>
        </nav>

    <main class="svelte-1gr3n62"><article><h1>Big O notation</h1>

    <time>25 Aug 2016 at 13:00</time>

    <div class="content"><p>The best big O notation explanation I’ve ever saw I’ve found on… Google Play Market! I was
hanging around, looking for the suggested software and, for some reason, I’ve decided to
install some educational application for programmers. And here’s what I’ve found…</p>
<!--more-->

<p>Big O notation shows, how many steps or memory units will the algorithm use to complete,
at its maximum. Here’s an example:</p>
<pre><code class="language-java"><span class="token keyword">void</span> <span class="token function">someAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// part 1</span>
  <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// part 2</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// part 3</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// part 4</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Let’s take a look at each of four algorithm parts. Part 1 just calls some function, <code>doSomething()</code>.
Let’s assume it takes some constant amount of time to complete, <code>C</code>. The time complexity of calling
a function, which uses constant time to complete is <code>O(1)</code>. So part 1 will take <code>O(1)</code> time to complete.</p>
<p>Part 2 has a loop, which has exactly 10 iterations, calling <code>doSomething()</code> at each iteration. As we’ve
discussed above, this part takes <code>10 * C</code> (ten calls of <code>doSomething()</code> function, which takes <code>C</code> steps to
complete) steps. This is a constant value too, so part 2 of the function <code>myAlgorithm()</code> will have the
complexity of <code>O(1)</code>.</p>
<p>Part 3 has a loop, whose number of iterations relies on the input parameter of <code>myAlgorithm()</code>, namely <code>n</code>.
We do not know, what value the <code>n</code> will take. But as it increases, the steps, needed for this part to complete
increases too. So the complexity of this part will be <code>O(n)</code>.</p>
<p>Part 4 has two nested loops. As in the previous case, when <code>n</code> increases, the steps needed by this part to
complete will increase even faster: for <code>n = 1</code> it will take exactly <code>C</code> steps to complete (recall:
the complexity of <code>doSomething()</code> is <code>C</code>); for <code>n = 2</code> it will take <code>2 * 2 * C = 4 * C</code> steps to complete;
for <code>n = 10</code> the amount of steps would be <code>10 * 10 * C = 100 * C</code>. One can notice that the complexity
equals to <code>n * n * C</code>. This is quadratical complexity, denoted as <code>O(n^2)</code>.</p>
<p>The final complexity of an algorithm could be calculated by easily adding all those parts’ complexities:
<code>O(1) + O(1) + O(n) + O(n^2)</code>. But here’s the trick: if the <code>n</code> is relatively small (like, <code>10</code> or <code>100</code>),
the difference between <code>O(1)</code> and <code>O(n)</code> is huge (noticeable, at least). But if we say the value of <code>n</code>
is insanely large (like, billiards), we may not notice the <code>O(1)</code> is just nothing, compared to <code>O(n)</code>. And
<code>O(n)</code> is just nothing, when compared to <code>O(n^2)</code>. And here comes the rule: total complexity of an algorithm is
the maximum needed amount of steps to complete. Just as follows:</p>
<ul>
<li><code>O(C) = O(1)</code></li>
<li><code>O(1) + O(n) = O(n)</code></li>
<li><code>O(n) + O(n^2) = O(n^2)</code></li>
</ul>
<p>Here comes the comparison of the known complexities: <code>O(1) &lt; O(log n) &lt; O(n) &lt; O(n*log n) &lt; O(n^m)</code>.</p>
<p>But we can measure not time consumption only, using the big O notation. It is also handy for memory
complexity measurements.</p>
<p>Here the same rules apply, except of <em>“steps to complete”</em> we use
<em>“memory cells allocated”</em>. So we will count the amount of allocated memory. This is mostly used
by lists, not by objects and structures (as they always use the same memory amount). Check this out:</p>
<pre><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Moo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
  <span class="token keyword">float</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
  <span class="token keyword">float</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>Both <code>Moo</code> and <code>Foo</code> will use the same amount of memory initially (since pointers in C++ are just
integer memory addresses’ values and floats use same 4 bytes - just as integers do). But depending on
how many memory we will allocate for <code>Foo.d</code> we will get the different values. Consider the continuation
of this example below:</p>
<pre><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">myAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// part 1</span>
  Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// part 2</span>
  foo<span class="token operator">-></span>d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// part 3</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// part 4</span>
  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, in part 1, we have just an instance of <code>Foo</code> class, which uses
<code>3 * int + float* = 3 * 1 + 1 = 4</code> memory cells. As in case with time complexity, this amount is constant,
thus it has <code>O(1)</code> memory consumption.</p>
<p>In part 2, however, we extend this amount by placing 10 memory cells into
<code>foo.d</code> field, but this does not change much, as <code>foo</code> will use constant memory cells anyway. So, part 2 has
memory complexity of <code>O(1)</code> too.</p>
<p>In part 3 we create a new array, and its size depends on function’s argument <code>n</code>, so its memory consumption
is <code>O(n)</code>.</p>
<p>In part 4 we create a two-dimensional array, whose size is <code>n * 15</code>. We can split its size into two components:
<code>O(n) * O(15) = O(n)</code>, because <code>15</code> is <code>15</code> no matter what.</p>
<p>And the total memory complexity of the algorithm is <code>O(1) + O(1) + O(n) + O(n) = O(n)</code>.</p>
<p>For even more simple <code>O(*)</code> calculus, replace the <code>+</code> operator with the <code>min</code> operator:
memory complexity of <code>myAlgorithm()</code> is <code>max(O(1), O(1), O(n), O(n)) = O(n)</code>.</p>
</div>
</article></main>

    

    <script src="/blog2-ssr/lazyLoadImages.js"></script></body>
</html>