<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="/blog2-ssr/images/favicon-compressed.webp">
    <link rel="shortcut icon" href="/blog2-ssr/images/favicon-compressed.webp">
    <link rel="apple-touch-icon" href="/blog2-ssr/images/favicon-compressed.webp">

    <link rel="stylesheet" href="/blog2-ssr/shared.css">
    <link rel="stylesheet" href="/blog2-ssr/prism.css">

    <title>Loooong lists with Clojure</title></head>
<body class="svelte-1gr3n62"><style>:root{--left-side:200px;--right-side:200px;--nav-height:64px;--background-color:#FFD166;--primary-color:#06D6A0;--primary-accent-color:#049F76;--secondary-color:#118AB2;--sub-color:#073B4C;--nav-background:#fff;--article-background:#fff
    }body.svelte-1gr3n62.svelte-1gr3n62{padding:0;margin:0;color:var(--sub-color);background:var(--background-color);font-family:Roboto, "Helvetica Neue", Arial, sans-serif;font-size:18px;display:grid;grid-template:var(--nav-height) auto var(--nav-height)/var(--left-side) calc(100% - var(--left-side) - var(--right-side)) var(--right-side)
    }nav.top.svelte-1gr3n62 .links.svelte-1gr3n62{grid-area:1/2/2/3;display:flex;align-items:center
    }nav.top.svelte-1gr3n62 .links a.svelte-1gr3n62{margin-right:1em
    }a.svelte-1gr3n62.svelte-1gr3n62{color:var(--secondary-color);text-decoration:none
    }a.svelte-1gr3n62.svelte-1gr3n62:hover,a.svelte-1gr3n62.svelte-1gr3n62:active{color:var(--sub-color)
    }footer.svelte-1gr3n62.svelte-1gr3n62{grid-area:3/1/4/4;background:#fff;display:inline-grid;grid-template:100%/var(--left-side) auto var(--right-side)
    }nav.top.svelte-1gr3n62.svelte-1gr3n62{background-color:var(--nav-background);display:inline-grid;grid-template:100%/var(--left-side) auto var(--right-side);grid-area:1/1/2/4
    }main.svelte-1gr3n62.svelte-1gr3n62{grid-area:2/2/3/3;margin-top:1em;display:flex;flex-direction:column
    }@media screen and (max-width: 1340px){:root{--left-side:0px;--right-side:0px
        }body.svelte-1gr3n62.svelte-1gr3n62{background:var(--background-color)
        }nav.top.svelte-1gr3n62 .links.svelte-1gr3n62{justify-content:space-around
        }}
.btn.svelte-7idbpu{display:inline-flex;font-size:18px;color:#fff;background:var(--primary-color);padding:10px;border-radius:8px
    }.btn.svelte-7idbpu:hover{background:var(--primary-accent-color);color:#fff
    }</style>

    <nav class="top svelte-1gr3n62">
            <div class="links svelte-1gr3n62"><a class="nav-link nav-item svelte-1gr3n62" href="/blog2-ssr/">Home</a>
                <a class="nav-link nav-item svelte-1gr3n62" href="/blog2-ssr/about/">About</a></div>
        </nav>

    <main class="svelte-1gr3n62"><article><h1>Loooong lists with Clojure</h1>

    <time>16 Oct 2015 at 17:11</time>

    <div class="content"><h2 id="whaaaaat">Whaaaaat?</h2>
<p>These days I was given a reeeeally interesting homework at the university. I was given a set of
MD5 hashes, calculated from single words <em>(taken from Libre Office’ dictionaries)</em> with a given
sault. And the task was to find all those words.</p>
<p>So, the first idea which came to my mind was using an internet service for MD5 breaking. But…
aaarrrggghhh! There’s a sault, so the webservice, looking for words over a dictionary fails to
find mines…</p>
<p>So the second idea was to take that dictionary from Libre Office and iterate through it. At the
end, it worked =) And worked reeeally fast. But that is not an interesting part.</p>
<p>I wandered if I could find those words in my dictionary, generated by my own code.</p>
<!--more-->

<h2 id="hoooow">Hoooow?</h2>
<p>I was thinking of writing it functionally. Really functionally, in Clojure. And, highly motivated
by how good Clojure is at parallelism <em>(sarcasm?..)</em>, I started thinking. After many tries and
even installing Clojure REPL on my phone and writing code all the way home from university and work,
I asked my dear friend to help me with this.</p>
<p>And so we went non-functional way first… We wrote a Java class, having two methods for generating
words recursively. The idea was, to make a new word by appending it with each letter, then appending
each of the alphabet’ letters to this word and so on, until we get all the words of <code>N</code> characters.</p>
<LazyImg src="/images/looong-tasks-with-clojure/collaborative-java.webp" />

<p>When our pretty class was created and working <em>(for some cases)</em>, we decided to do it more
Java-correct and created two more classes, implementing a single interface, doing the same thing
but differently each. And decided to skip writing <code>context.xml</code> and going deeper with Spring =)</p>
<pre><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">IWordGenerator</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MooWordGenerator</span> <span class="token keyword">implements</span> <span class="token class-name">IWordGenerator</span> <span class="token punctuation">{</span>
    <span class="token comment">// Best practices in naming convention =)</span>

    <span class="token comment">/** not necessary */</span>
    <span class="token keyword">public</span> <span class="token class-name">MooWordGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completeWords</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> cs<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> word <span class="token operator">=</span> cs<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token operator">::</span><span class="token function">toString</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// what the fuuck???</span>

            words<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token char">'z'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> ncs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            ncs<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ncs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">completeWords</span><span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> ncs<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> cs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">completeWords</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> cs<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> words<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">FooWordGenerator</span> <span class="token keyword">implements</span> <span class="token class-name">IWordGenerator</span> <span class="token punctuation">{</span>
    <span class="token comment">/** */</span>
    <span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> sb<span class="token punctuation">;</span>
    <span class="token comment">/** */</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> words<span class="token punctuation">;</span>

    <span class="token comment">/**
     * Creates list of strings containing all possible words with given length.
     *
     * @param length - the length of words to generate.
     * @return List&lt;String> words.
     *
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> allWords <span class="token operator">=</span> <span class="token function">getAllWords</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sb <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        words <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> allWords<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * Creates list of strings containing all possible words with given length.
     * Possible to run this method ONLY ONCE! Next calls will
     * give the wrong result.
     *
     * @param length - the length of words to generate.
     * @return List&lt;String> words.
     *
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getAllWords</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token char">'c'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//doesn't work</span>
            <span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">getAllWords</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">getWords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span><span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token function">getWords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * Get string builder. create new if null.
     * @return sb.
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> <span class="token function">getSB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sb <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * Get words array. create new if null.
     * @return words.
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getWords</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>words <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> words<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/** D: go smoke
         *
         *
         *
         *
         **/</span>
        <span class="token class-name">IWordGenerator</span> gen1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MooWordGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">IWordGenerator</span> gen2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FooWordGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Moo:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        gen1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Foo:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        gen1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The solution was made. It worked reaaaally loooooong for words with six letters. I decided to start
working on Clojure implementation of this idea. I started writing a function, generating a list of
words. <em>Word</em> in this code was represented by a list of numbers from 0 to 25, associated with
corresponding letters of latin alphabet. That allowed me not to bore myself with generating a
list of chars and use a built-in Clojure’ <code>range</code> function.</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> gen-words <span class="token punctuation">[</span>len cs<span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">=</span> <span class="token number">0</span> len<span class="token punctuation">)</span>
        cs
        <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">gen-words</span> <span class="token punctuation">(</span><span class="token keyword">dec</span> len<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">conj</span> cs %<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>But ended up with the same results as for Java on six letters. Moreover, my implementation
gave me strangely-nested list, which caused writing special flattening functions; Clojure’s
<code>flatten</code> gave me a plain list, where all the words were merged with others.</p>
<p>I needed performance boost!</p>
<p>I tried using <code>pmap</code> instead of <code>map</code> to parallelize the list generation process, but that
did not helped. I also tried generating a list of <code>future</code> objects, so each list element will be
calculated only when needed:</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> gen-words <span class="token punctuation">[</span>len cs<span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">=</span> <span class="token number">0</span> len<span class="token punctuation">)</span>
        cs
        <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">future</span> <span class="token punctuation">(</span><span class="token function">gen-words</span> <span class="token punctuation">(</span><span class="token keyword">dec</span> len<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">conj</span> cs %<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>But that caused my futures never to be finished. And then my collegue reminded me I can create
a function, which will only rely on a previously generated word and will return the next one,
not a list of words. <em>“That might save me lot of memory!”</em>, I thought and started coding.</p>
<p>And finished with this pretty implementation:</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> next-word <span class="token punctuation">[</span>prev-word<span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>
            l <span class="token punctuation">(</span><span class="token keyword">drop-while</span> <span class="token punctuation">(</span><span class="token keyword">partial</span> = <span class="token number">25</span><span class="token punctuation">)</span> prev-word<span class="token punctuation">)</span>
            l-size <span class="token punctuation">(</span><span class="token keyword">-</span> <span class="token punctuation">(</span><span class="token keyword">count</span> prev-word<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">count</span> l<span class="token punctuation">)</span><span class="token punctuation">)</span>
            zeroes <span class="token punctuation">(</span><span class="token keyword">repeat</span> l-size <span class="token number">0</span><span class="token punctuation">)</span>
            new-head <span class="token punctuation">(</span><span class="token keyword">inc</span> <span class="token punctuation">(</span><span class="token keyword">first</span> l<span class="token punctuation">)</span><span class="token punctuation">)</span>
            new-tail <span class="token punctuation">(</span><span class="token keyword">rest</span> l<span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
        <span class="token punctuation">(</span><span class="token keyword">concat</span> zeroes <span class="token punctuation">[</span>new-head<span class="token punctuation">]</span> new-tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>See, in this implementation no word is being saved nowhere except the return value or an
input argument <em>(well, actually the output from a function is then being used as an input
for itself)</em>.</p>
<p>I converted all the word representations into words with this over-complicated function:</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> word-to-str <span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">clojure.string/join</span> <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token punctuation">(</span><span class="token keyword">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token char">\a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> %<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>And then I created a function, generating a list of those words.</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> words
    <span class="token punctuation">(</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">words</span> n <span class="token punctuation">(</span><span class="token keyword">repeat</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token punctuation">[</span>n w<span class="token punctuation">]</span>
        <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>str-w <span class="token punctuation">(</span><span class="token function">word-to-str</span> w<span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">every?</span> <span class="token punctuation">(</span><span class="token keyword">partial</span> = <span class="token number">25</span><span class="token punctuation">)</span> w<span class="token punctuation">)</span>
                <span class="token punctuation">[</span>str-w<span class="token punctuation">]</span>
                <span class="token punctuation">(</span><span class="token function">lazy-seq</span> <span class="token punctuation">(</span><span class="token keyword">cons</span> str-w <span class="token punctuation">(</span><span class="token function">words</span> n <span class="token punctuation">(</span><span class="token function">next-word</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Yeah, again! But not a plain list or vector, as previously, nooo. I generated a lazy-sequence!
This is where Clojure meets ES6 generators =) See, lazy sequence in Clojure is a <em>(possibly)</em> endless
collection, each element of which could be evaluated <em>(or assigned a value)</em> when it is
needed. Besides that, collection takes almost no memory and its creation costs almost
no time. Saying <em>almost</em> I mean the time, needed to construct and store an object in memory.
Just a simple, plain class’ instance.</p>
<p>But that was not an option - it took nearly <code>45 minutes</code> to find all the 6-letter words even
when using <code>pmap</code> and eaten SO much damn memory!..</p>
<LazyImg class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/mem-consumption-1.webp" />

<p>However, idle REPL eats much memory too:</p>
<LazyImg class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/idle-repl-memory.webp" />

<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> seq-contains? <span class="token punctuation">[</span>coll target<span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token keyword">some</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">=</span> target %<span class="token punctuation">)</span> coll<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">defn</span> decode-<span class="token number">1</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span> ws <span class="token punctuation">(</span><span class="token keyword">filter</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token function">seq-contains?</span> input-hashes <span class="token punctuation">(</span><span class="token function">encode</span> %<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">words</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">]</span>
        <span class="token punctuation">(</span><span class="token function">pmap</span> <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token punctuation">[</span>w <span class="token punctuation">(</span><span class="token function">encode</span> w<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ws<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Then I enhanced this implementation eliminating the <code>lazy-seq</code> completely. So, there was no
collection creation at all! All the results were printed onto screen right away when found.
This could be replaced with any other storage - file, database, anything! Printing results
on the screen is a habit from my student years…</p>
<pre><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> decode-<span class="token number">2</span>
    <span class="token punctuation">(</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">decode-</span><span class="token number">2</span> n <span class="token punctuation">(</span><span class="token keyword">repeat</span> n <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token punctuation">[</span>n prev-word<span class="token punctuation">]</span>
        <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>
                prev-word-str <span class="token punctuation">(</span><span class="token function">word-to-str</span> prev-word<span class="token punctuation">)</span>
            <span class="token punctuation">]</span>
            <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">seq-contains?</span> input-hashes <span class="token punctuation">(</span><span class="token function">encode</span> prev-word-str<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">encode</span> prev-word-str<span class="token punctuation">)</span> prev-word-str<span class="token punctuation">)</span>
                <span class="token boolean">nil</span><span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">every?</span> <span class="token punctuation">(</span><span class="token keyword">partial</span> = <span class="token number">25</span><span class="token punctuation">)</span> prev-word<span class="token punctuation">)</span>
                <span class="token boolean">nil</span>
                <span class="token punctuation">(</span><span class="token keyword">recur</span> n <span class="token punctuation">(</span><span class="token function">next-word</span> prev-word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>The memory consumption got minimal:</p>
<LazyImg class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/mem-consumption-2.webp" />

<p>And the time consumption was not <strong>that</strong> good, though…</p>
<pre><code class="language-clojure">task1.core=> <span class="token punctuation">(</span><span class="token keyword">time</span> <span class="token punctuation">(</span><span class="token function">decode-</span><span class="token number">2</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
4adbc43d3e1b432aea5e657cd57016de rampa
bba60169d41b2dce7d0b37b2f9d637e0 kolej
7914da949837cbdecf35cbf5951ad518 argon
<span class="token string">"Elapsed time: 92879.138203 msecs"</span>
<span class="token boolean">nil</span>
</code></pre>
<p>Running it from non-REPL environment helped a bit:</p>
<pre><code class="language-bash">╰─$ lein run
4adbc43d3e1b432aea5e657cd57016de rampa
bba60169d41b2dce7d0b37b2f9d637e0 kolej
7914da949837cbdecf35cbf5951ad518 argon
<span class="token string">"Elapsed time: 73796.575567 msecs"</span>
</code></pre>
<h2 id="profit">Profit?</h2>
<p><em>But where’s the Saint Graal for brute-forcing like that? How to speed that algorithm?</em>
I don’t know, actually =) Well, I know how to do it with <em>OpenMP</em>, I have a couple of
ideas on how this task could be distributed, but those desire a separate article.</p>
</div>
</article></main>

    

    <script src="/blog2-ssr/lazyLoadImages.js"></script></body>
</html>